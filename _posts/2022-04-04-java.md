---
layout: post
title: "about_Java"
description: "자바에 관하여"
categories: [java]
tags: [java_info, eclips, ]
redirect_from:
  - /2022/04/04/
---

> 자바에 관하여.

* Kramdown table of contents
{:toc .toc}

# <ins>JAVA의 super & super()에 대하여</ins>
## super
> super는 자식 클래스가 부모 클래스로부터 상속받은 멤버를 참조할 때 사용하는 참조 변수다. 클래스 내의 멤버변수와 지역변수의 이름이 같을 경우, 구분을 위해 this를 사용하듯 부모 클래스와 자식 클래스의 멤버의 이름이 같을 경우 super를 사용한다. this와 super는 인스턴스의 주소 값을 저장하는데 static 메서드(클래스 메서드)와는 무관하게 사용된다.

<b>예제)</b>
~~~
class JavaA {
	public static void main(String[] args) {
		Child child = new Child();
		child.childMethod();
	}
}

class Parent {
	int x = 10;
}

class Child extends Parent {
	int x = 20;

	void childMethod() {
		System.out.println("x = " + x);
		System.out.println("this.x = " + this.x);
		System.out.println("super.x = " + super.x);
	}
}
~~~
<b>결과)</b>
~~~
x = 20
this.x = 20
super.x = 10
~~~

## super()

> super()는 부모 클래스의 생성자를 호출하는 메서드이다. 상속받은 자식 클래스가 부모 클래스의 멤버를 사용할 경우가 있을 수도 있으므로 부모 클래스를 우선적으로 초기화해야 한다. 부모 클래스의 생성자는 자식 클래스의 첫 줄에서 호출 해준다. 이러한 부모 클래스에 대한 생성자 호출은 상속관계에 따라 Object 클래스까지 올라가서 마무리된다.<br>
정리하자면, 상속할 경우 Object 클래스를 제외한 모든 클래스는 첫 줄에 반드시 자신의 클래스의 또 다른 생성자인 this() 또는 부모 클래스의 생성자인 super()를 호출해줘야 한다. 그렇지 않으면 컴파일러가 자동으로 super()를 생성자의 첫 줄에 호출할 것이다.

<b>예제</b>
~~~
class JavaB {
	public static void main(String[] args) {
		Riding riding = new Riding();  // Riding() 생성자로 초기화 및 인스턴스 생성
		System.out.println("riding.x = " + riding.x);
		System.out.println("riding.y = " + riding.y);
		System.out.println("riding.z = " + riding.z);
	}
}

class Distance {
	int x = 10;
	int y = 20;

	Distance(int x, int y) {  // 생성자의 첫줄에 다른 생성자를 호출하지 않았기 때문에, 컴파일러가 이 부분에 super()를 호출한다.
		                  // 부모 클래스이므로 Object 클래스의 super()가 호출된다.
		this.x = x;
		this.y = y;
	}
}

class Riding extends Distance {
	int z = 30;

	Riding() {
		this(100, 200, 300);  // 자신의 클래스의 또다른 생성자 호출
	}

	Riding(int x, int y, int z) {
		super(x, y);  // 부모 클래스 생성자 호출
		this.z = z;
	}	
}
~~~
<b>결과)</b>
~~~
riding.x = 100
riding.y = 200
riding.z = 300
~~~

출처: https://freestrokes.tistory.com/72 [FREESTROKES DEVLOG]


# <ins>상속에 관하여(Inheritance)</ins>
## OOP(Object-Oriented Programming, 객체 지향 프로그래밍)
> 1. 상속과 인터페이스(계층성)
  2. 다형성, 사용편의성(모듈화)
  3. 캡슐화, 정보은닉
  4. 자료 추상화(모델링)
  5. 동적 바인딩

<a class="post-image" href="{{site.baseurl}}/assets/images/java/object.png">
<img itemprop="image" data-src="{{site.baseurl}}/assets/images/java/object.png" src="{{site.baseurl}}/assets/javascripts/unveil/loader.gif" alt="왜안떠" />
</a>
> 위의 상자 각가은 모두 객체(Object)이고, 자바 용어로는 Class이다. 이러한 계층을 표현하기 위해 만들어진 것이 바로 상속.<br>
예를 들어 동물의 특징 '움직이다'를 포유류, 조류, 파충류는 그대로 물려 받는다. 즉, move()라는 메서드를 포유류, 조류, 파충류 객체가 모두 사용할 수 있다는 것.<br>
하위 객체는 상위 객체(부모)의 특징을 물려 받는다.<br><br>
또한 변수도 상위 객체에 선언되어 있다면 물려받을 수 있다. ex)지역, 나이...<br>
이러한 메서드들과 변수를 새로 구현을 하는가, 아니면 그대로 사용하는가에 따라서 상속의 형태가 달라지게 된다.<br>
1. extends
	부모 객체에서 선언/ 정의를 모두하며, 자식객체는 메서드/ 변수를 그대로 사용할 수 있다.
2. implements(interface)
	부모 객체는 선언만 하며 정의(내용)은 자식 객체에서 오버라이딩(재정의)해서 사용해야 한다.
3. abstract
	extends와 interface의 혼합으로, extends를 하면서 몇 개는 추상메서드로 구현되어 있다.

먼저 접근제어자에 대해서 알아보자.

|public|protected|default|private|
|---|---|---|---|
|All|상속 OR 동일패키지|상속 && 동일패키지|클래스 내부|

## extends
> 상속의 대표적인 형태이다. 부모 메서드를 그대로 사용할 수 있으며, 오버라이딩 할 필요도 없이 부모에게 구현되어 있는 것을 직접 사용 가능하다.

~~~
class Vehicle {
  protected int speed = 60;
  
  public int getSpeed(){
    return speed;
  }
  public void setSpeed(int speed){
    this.speed = speed;
  }
}

class MotorCycle extends Vehicle{
  public void printspd(){
    System.out.println(speed);
  }
}

public class ExtendsSample {
  public static main (String[] args){
    MotorCycle A = new MotorCycle();
    System.out.println(A.getSpeed());
    A.printspd();
  }
}
~~~

> MotorCycle이라는 클래스는 Vehicle을 상속 받았다. 그리고 직접적으로 Vehicle의 getSpeed() 메서드로 speed를 print했다. extends를 했으니 메서드와 변수까지 사용이 가능해지는 것이다.<br><br>
이어서 implements인데, 자바는 "다중상속"을 지원하지 않는다.<br>
다중상속이란 부모클래스가 두 개 이상 존재할 수 있다는 것인데, 자바에서는 이를 지원하지 않는다.<br>즉 public class MotorCycle extends Price, Brand{...} 이것처럼 불가능 하다는 것이다. 그래서 등장한 것이 <ins>implements(interface)</ins>이다.


## implements
> implements의 가장 큰 특징은 부모의 메서드를 반드시 오버라이딩(Overriding/재정의)해야 한다는 것이다. 또한 public class MotorCycle extends Price, Brand{...} 같은 다중상속을 대신 가능하게 해준다.

~~~
interface TestInterface{
  public static int num = 8;
  public void fun1();
  public void fun2();
}

class InterfaceExam implements TestInterface{
  @Override
  public void fun1(){
    System.out.println(num);
  }
  
  @Override
  public void fun2() {
    
  }
}

public class InterfaceSample{
  public static void main(String args[]){
    InterfaceExam exam = new InterfaceExam();
    exam.fun1();
  }
}
~~~

* 정리
1. extends는 일반 클래스와 abstract 클래스 상속에 사용되고, implements는 interface 상속에 사용된다.
2. class가 class를, interface가 interface를 상속 받을 땐 extends를 사용한다.
3. class가 interface를 사용할 땐 implements를 써야하고, interface가 class를 사용할 땐 implements를 쓸 수 없다.
4. extends는 클래스 한 개만 상속 받을 수 있다.
5. extends 자식 클래스는 부모 클래스의 기능을 사용한다.
6. implements는 다중상속이 가능하다.
7. implements는 설계 목적으로 구현 가능하다.
8. implements를 사용하는 클래스는 implements(interface)의 내용을 모두 사용해야 한다(Overriding).
9. extends는 클래스를 확장하는 것이고, implements는 interface를 구현하는 것이다.
10. interface와 보통 class의 차이는 인터페이스는 정의한 메소드를 구현하지 않아도 된다.
11. interface를 상속받는 클래스에서 인터페이스에 정의된 메소드를 구현하면 된다.