---
layout: post
title: "about_Java"
description: "자바에 관하여"
categories: [java]
tags: [java_info, eclips, ]
redirect_from:
  - /2022/04/04/
---

> 자바에 관하여.

* Kramdown table of contents
{:toc .toc}

# <ins>JAVA란 무엇인가</ins>
## Java란?
> Java는 썬 마이크로시스템즈(Sun Microsystems, Inc. 이하 썬)의 제임스 고슬링이라는 분과 다른 연구원들이 개발한, 컴퓨터 등의 다양한 기기에서 동작하는 프로그램을 제작할 수 있는 프로그래밍 언어입니다. 운영체제에 관계없이 실행할 수 있다는 특징을 지니고 있습니다.

#### Java의 간단한 역사
> 1991년 개발을 시작해 1996년 1월 공식 발표를 하였으며, 처음에는 공개된 프로젝트가 아닌 사유 소프트웨어였습니다. 그러나 2006년 말 Java를 GPL 라이선스로 공개함으로써 대부분의 코드를 오픈하였습니다. 2009년 제작사인 썬이 오라클이라는 회사로 인수합병되며 현재는 Java에 대한 권리 및 유지보수 책임 또한 오라클로 넘어가게 되었습니다.

#### Java의 철학
> 1.객체 지향 방법론을 사용해야 한다.<br>
2.같은 프로그램이 여러 운영 체제에서 실행될 수 있어야 한다.<br>
3.컴퓨터 네트워크 접근 기능이 기본으로 탑재되어 있어야 한다.<br>
4.원격 코드를 안전하게 실행할 수 있어야 한다.<br>
5.다른 객체 지향 언어들의 좋은 부분만 가지고 와서 사용하기 편해야 한다.

#### Java는 어떻게 다양한 운영체제에서 실행될 수 있었을까?
> Java로 만든 프로그램은 운영체제에 관계없이 실행할 수 있다는 특징을 가지고 있습니다. 그러나 사실 어떠한 운영체제에서도 실행할 수 있는 프로그램은 존재하지 않습니다.<br>
Java는 이러한 문제점을 해결하기 위해 특별한 방법을 사용했는데, 바로 '자바가상머신(Java Virtual Machine)'이라는 프로그램을 설치하도록 한 것입니다.<br>
각 운영체제에 맞추어 실행할 수 있는 자바가상머신을 운영체제별로 미리 만들어두고, Java로 만들어진 프로그램을 실행하면 이 자바가상머신을 통해 프로그램이 작동하도록 설계해둔 것입니다. 즉, Windows에는 Windows용 자바가상머신이 있고 Mac OS에는 Mac OS용의 자바가상머신이, Linux에는 Linux용 자바가상머신이 있어서, 각자 자신의 운영체제에 맞는 자바가상머신을 한번만 설치해두면 하나의 Java 프로그램을 어느 운영체제에서든지 실행할 수 있는 것입니다.<br>
Java가 나오기 이전까지 다른 대다수의 프로그래밍 언어로 프로그램을 만들게 되면, 똑같은 기능을 구현하기 위해 각 운영체제에 맞추어 새롭게 코드를 작성해야만 했습니다. 그러나 Java가 나타남으로 인해서 프로그래머들의 생산성이 비약적으로 증가하게 된 것입니다.<br>
자바가상머신을 컴퓨터에 설치해야만 Java로 제작한 프로그램이 실행된다는 단점이 있지만, 이를 통해 한 번 Java로 프로그램을 만들어두면 어떤 운영체제나 기기에서도 실행된다는 이점을 얻어간 것입니다.

### 절차지향(Procedural Programming)이란?
> 절차지향 프로그래밍이란 물이 위에서 아래로 흐르는 것처럼 순차적인 처리가 중요시 되며 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법.<br>
대표적인 절차지향 언어에는 C언어가 있습니다. 이는 컴퓨터의 작업 처리 방식과 유사하기 때문에 객체지향 언어를 사용하는 것에 비해 더 빨리 처리되어 시간적으로 유리합니다.<br>
옛날에는 하드웨어와 소프트웨어의 개발 속도차이가 크지 않았습니다. 하지만 하드웨어의 빠른 발전을 통해 컴퓨팅 환경은 급속도로 증가했지만 소프트웨어 개발 시간이 따라가지 못하게 되고 이런 상황에 소프트웨어의 개발시간을 단축하되 하드웨어에 기본적인 사양을 잡아먹어도 더 이상 큰 단점이 아니기에 모듈화, 캡슐화해서 개념적으로 접근하는 형태를 갖는 객체지향 프로그래밍이 탄생했습니다.<br>
객체지향 프로그래밍은 개발하려는 것을 기능별로 묶어 모듈화를 함으로써 같은 기능을 중복으로 연산하지 않거나 모듈을 재활용하기 때문에 유지보수에 유리합니다.

#### 장점
> 컴퓨터의 처리구조와 유사해 실행속도가 빠름

#### 단점
> - 유지보수가 어려움
- 실행 순서가 정해져 있으므로 코드의 순서가 바뀌면 동일한 결과를 보장하기 어려움
- 디버깅이 어려움

### 객체지향(Object Oriented Programming)이란?
> 객체지향의 정의를 살펴보면 객체지향이란 실제 세계를 모델링하여 소프트웨어를 개발하는 방법입니다. 객체지향 프로그래밍에서는 데이터와 절차를 하나의 덩어리로 묶어서 생각하게 됩니다. 이는 마치 컴퓨터 부품을 하나씩 사다가 컴퓨터를 조립하는 것과 같은 방법입니다. 객체 지향의 3대 특성은 다음과 같습니다.

1. <b>캡슐화</b>
> 캡슐화란 관련된 데이터와 알고리즘(코드)이 하나의 묶음으로 정리된 것으로써 개발자가 만들었으며, 관련된 코드와 데이터가 묶여있고 오류가 없어 사용이 편리합니다.<br>
데이터를 감추고 외부 세계와의 상호작용은 메소드를 통하는 방법인데, 라이브러리로 만들어 업그레이드하면 쉽게 바꿀 수 있습니다.<br>
메소드: 메시지에 따라 실행시킬 프로시저로서 객체지향 언어에서 사용되는 것. 객체지향 언어에서는 메시지를 보내 메소드를 수행시킴으로써 통신(communication)을 수행.

2. <b>상속</b>
> 상속은 이미 작성된 클래스를 이어 받아서 새로운 클래스를 생성하는 기법으로 위에서 말한 기존 코드를 재활용해서 사용하는 것을 의미. 객체지향 방법의 큰 장점중 하나.

3. <b>다형성</b>
> 다형성이란 하나의 이름(방법)으로 많은 상황에 대처하는 기법입니다. 개념적으로 동일한 작업을 하는 함수들에 똑같은 이름을 부여할 수 있으므로 코드가 더 간단해지는 효과가 있습니다.

#### 장점
> - 코드의 재활용성이 높음
- 코딩이 절차지향보다 간편함
- 디버깅이 쉬움

#### 단점
> - 처리속도가 절차지향보다 느림
- 설계에 많은 시간소요가 들어감

#### 객체지향과 절차지향의 차이점
> 객체지향의 반대는 절차지향이 아니고 절차지향의 반대는 객체지향이 아니다.<br>
위에서 설명한 것처럼 절차지향은 순차적으로 실행에 초점이 되어 있고 객체지향은 객체간의 관계 / 조직에 초점을 두고 있다. 이렇게 설명하면 객체지향은 절차적으로 실행되지 않냐? 라는 의문이 드는데 객체지향 역시 절차지향과 동일한 순서로 실행된다.


# <ins>JAVA 환경변수 설정(window10) 기준</ins>

> 1. 자바를 먼저 설치하고, 설치 경로를 확인합니다.
2. [내컴퓨터 -> 속성] 에서 '고급 시스템 설정으로 들어 갑니다.
3. 시스템 속성 창에서 '환경 변수'를 클릭합니다.
4. '환경 변수' 창에서 '시스템 변수'의 새로 만들기를 클릭하여 아래의 값을 추가합니다.(오타에 유의하여)
5. 변수이름 : CLASSPATH<br>
변수 값 : %classpath%;.1
6. 변수이름 : JAVA-HOME
변수 값 : C:\Program Files\Java\jdk1.8.0_281(본인이 설치한 자바 버전에 따라 다름)
7. 시스템 변수 path 값을 추가합니다.
'시스템 변수'의 목록 중 'Path'를 선택 후, 편집->새로 만들기 클릭 후 다음과 같은 값을 추가합니다.
8. 변수 값 : %JAVA_HOME%\bin
9. window키와 동시에 R키를 눌러 cmd(명령 프롬프트)를 실행하여 'java -verson'과 'javac -version'을 입력하여 제대로 되었는지 확인한다.
10. "javac는 내부 또는 외부 명령, 실행할 수 있는 프로그램, 또는 배치 파일이 아닙니다."와 같은 경고가 나오는 경우는 5번, 6번을 다시 확인 하시기 바랍니다.

출처: https://macchiato.tistory.com/9 [Cafe M]

# <ins>JAVA 클래스, 객체, 인스턴스의 개념과 차이</ins>
## 개념
> <b>Class(클래스)</b>
  * 객체를 만들어 내기 위한 설계도 혹은 틀.
  * 연관되어 있는 변수와 메서드의 집합.

> <b>Object(객체)</b>
  * 소프트웨어 세계에서 구현할 대상.
  * 클래스에 선언된 모양 그대로 생성된 실체.
  * <b>특징</b><br>
	=> '클래스의 인스턴스(instance)'라고도 부른다.<br>
	=> 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다.<br>
	=> OOP의 관점에서 클래스의 타입으로 선언되었을 때 '객체'라고 부른다.

> <b>Instance(인스턴스)</b>
  * 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체.<br>
  즉, 객체를 소프트웨어에 실체화 하면 그것을 '인스턴스'라고 부른다.<br>
  실체화된 인스턴스는 메모리에 할당된다.
  * <b>특징</b><br>
	=> 인스턴스는 객체에 포함된다고 볼 수 있다.<br>
	=> OOP의 관점에서 객체가 메모리에 할당되어 실제 사용될 때, '인스턴스'라고 부른다.<br>
	=> 추상적인 개념과 구체적인 객체 사이의 관계에 초점을 맞출 경우에 사용한다.<br>
	&#160;&nbsp; - '~의 인스턴스'의 형태로 사용.<br>
	&#160;&nbsp; - 객체는 클래스의 인스턴스.<br>
	&#160;&nbsp; - 객체 간의 링크는 클래스 간의 연관 관계의 인스턴스.<br>
	&#160;&nbsp; - 실행 프로세스는 프로그램의 인스턴스.<br>
	=> 즉, 인스턴스라는 용어는 반드시 클래스와 객체 사이의 관계로 한정지어서 사용할 필요는 없다.<br>	
	=> 인스턴스는 어떤 원본(추상적인 개념)으로부터 '생선된 복제본'을 의미한다.

```java
/* 클래스 */
public class Animal {
  ...bla,bla
}
/* 객체와 인스턴스 */
public class Main {
  public static void main(String[] args) {
    Animal cat, dog; // '객체'

    // 인스턴스화
    cat = new Animal(); // cat은 Animal 클래스의 '인스턴스'(객체를 메모리에 할당)
    dog = new Animal(); // dog은 Animal 클래스의 '인스턴스'(객체를 메모리에 할당)
  }
}
```

## 차이
> * <b>Class(클래스) VS Object(객체)</b><br>
	=> 클래스는 '설계도', 객체는 '설계도로 구현한 모든 대상'을 의미한다.
> * <b>Object(객체) VS Instance(인스턴스)</b><br>	
	=> 클래스의 타입으로 선언되었을 때 객체라고 부르고, 그 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다.<br>
	=> 객체는 현실 세계에 가깝고, 인스턴스는 소프트웨어 세계에 가깝다.<br>
	=> 객체는 '실체', 인스턴스는 '관계'에 초점을 맞춘다. 객체를 '클래스의 인스턴스'라고도 부른다.

## 참고
> * <b>추상화 기법</b>
1. 분류(Classification)<br>
&nbsp;&nbsp; - 객체 -> 클래스<br>
&nbsp;&nbsp; - 실재하는 객체들을 공통적인 속성을 공유하는 범부 또는 추상적인 개념으로 묶는 것<br>
2. 인스턴스화(Instantiation)<br>
&nbsp;&nbsp; - 클래스 -> 인스턴스<br>
&nbsp;&nbsp; - 분류의 반대 개념. 범주나 개념으로부터 실재하는 객체를 만드는 과정<br>
&nbsp;&nbsp; - 구체적으로 클래스 내의 객체에 대해 특정한 변형을 정의하고, 이름을 붙인 다음, 그것을 물리적인 어떤 장소에 위치시키는 등의 작업을 통해 인스턴스를 만드는 것을 말한다.<br>
&nbsp;&nbsp; - ‘예시(Exemplification)’라고도 부른다.


# <ins>JAVA의 super & super()에 대하여</ins>
## super
> super는 자식 클래스가 부모 클래스로부터 상속받은 멤버를 참조할 때 사용하는 참조 변수다. 클래스 내의 멤버변수와 지역변수의 이름이 같을 경우, 구분을 위해 this를 사용하듯 부모 클래스와 자식 클래스의 멤버의 이름이 같을 경우 super를 사용한다. this와 super는 인스턴스의 주소 값을 저장하는데 static 메서드(클래스 메서드)와는 무관하게 사용된다.

<b>예제)</b>
```java
class JavaA {
	public static void main(String[] args) {
		Child child = new Child();
		child.childMethod();
	}
}

class Parent {
	int x = 10;
}

class Child extends Parent {
	int x = 20;

	void childMethod() {
		System.out.println("x = " + x);
		System.out.println("this.x = " + this.x);
		System.out.println("super.x = " + super.x);
	}
}
```
<b>결과)</b>
```java
x = 20
this.x = 20
super.x = 10
```

## super()

> super()는 부모 클래스의 생성자를 호출하는 메서드이다. 상속받은 자식 클래스가 부모 클래스의 멤버를 사용할 경우가 있을 수도 있으므로 부모 클래스를 우선적으로 초기화해야 한다. 부모 클래스의 생성자는 자식 클래스의 첫 줄에서 호출 해준다. 이러한 부모 클래스에 대한 생성자 호출은 상속관계에 따라 Object 클래스까지 올라가서 마무리된다.<br>
정리하자면, 상속할 경우 Object 클래스를 제외한 모든 클래스는 첫 줄에 반드시 자신의 클래스의 또 다른 생성자인 this() 또는 부모 클래스의 생성자인 super()를 호출해줘야 한다. 그렇지 않으면 컴파일러가 자동으로 super()를 생성자의 첫 줄에 호출할 것이다.

<b>예제</b>
```java
class JavaB {
	public static void main(String[] args) {
		Riding riding = new Riding();  // Riding() 생성자로 초기화 및 인스턴스 생성
		System.out.println("riding.x = " + riding.x);
		System.out.println("riding.y = " + riding.y);
		System.out.println("riding.z = " + riding.z);
	}
}

class Distance {
	int x = 10;
	int y = 20;

	Distance(int x, int y) {  // 생성자의 첫줄에 다른 생성자를 호출하지 않았기 때문에, 컴파일러가 이 부분에 super()를 호출한다.
		                  // 부모 클래스이므로 Object 클래스의 super()가 호출된다.
		this.x = x;
		this.y = y;
	}
}

class Riding extends Distance {
	int z = 30;

	Riding() {
		this(100, 200, 300);  // 자신의 클래스의 또다른 생성자 호출
	}

	Riding(int x, int y, int z) {
		super(x, y);  // 부모 클래스 생성자 호출
		this.z = z;
	}	
}
```
<b>결과)</b>
~~~java
riding.x = 100
riding.y = 200
riding.z = 300
~~~

출처: https://freestrokes.tistory.com/72 [FREESTROKES DEVLOG]


# <ins>상속에 관하여(Inheritance)</ins>
## OOP(Object-Oriented Programming, 객체 지향 프로그래밍)
> 1. 상속과 인터페이스(계층성)
  2. 다형성, 사용편의성(모듈화)
  3. 캡슐화, 정보은닉
  4. 자료 추상화(모델링)
  5. 동적 바인딩

<a class="post-image" href="{{site.baseurl}}/assets/images/java/object.png">
<img itemprop="image" data-src="{{site.baseurl}}/assets/images/java/object.png" src="{{site.baseurl}}/assets/javascripts/unveil/loader.gif" alt="왜안떠" />
</a>
> 위의 상자 각가은 모두 객체(Object)이고, 자바 용어로는 Class이다. 이러한 계층을 표현하기 위해 만들어진 것이 바로 상속.<br>
예를 들어 동물의 특징 '움직이다'를 포유류, 조류, 파충류는 그대로 물려 받는다. 즉, move()라는 메서드를 포유류, 조류, 파충류 객체가 모두 사용할 수 있다는 것.<br>
하위 객체는 상위 객체(부모)의 특징을 물려 받는다.<br><br>
또한 변수도 상위 객체에 선언되어 있다면 물려받을 수 있다. ex)지역, 나이...<br>
이러한 메서드들과 변수를 새로 구현을 하는가, 아니면 그대로 사용하는가에 따라서 상속의 형태가 달라지게 된다.<br>
1. extends
	부모 객체에서 선언/ 정의를 모두하며, 자식객체는 메서드/ 변수를 그대로 사용할 수 있다.
2. implements(interface)
	부모 객체는 선언만 하며 정의(내용)은 자식 객체에서 오버라이딩(재정의)해서 사용해야 한다.
3. abstract
	extends와 interface의 혼합으로, extends를 하면서 몇 개는 추상메서드로 구현되어 있다.

먼저 접근제어자에 대해서 알아보자.

|public|protected|default|private|
|---|---|---|---|
|All|상속 OR 동일패키지|상속 && 동일패키지|클래스 내부|

## extends
> 상속의 대표적인 형태이다. 부모 메서드를 그대로 사용할 수 있으며, 오버라이딩 할 필요도 없이 부모에게 구현되어 있는 것을 직접 사용 가능하다.

~~~java
class Vehicle {
  protected int speed = 60;
  
  public int getSpeed(){
    return speed;
  }
  public void setSpeed(int speed){
    this.speed = speed;
  }
}

class MotorCycle extends Vehicle{
  public void printspd(){
    System.out.println(speed);
  }
}

public class ExtendsSample {
  public static main (String[] args){
    MotorCycle A = new MotorCycle();
    System.out.println(A.getSpeed());
    A.printspd();
  }
}
~~~

> MotorCycle이라는 클래스는 Vehicle을 상속 받았다. 그리고 직접적으로 Vehicle의 getSpeed() 메서드로 speed를 print했다. extends를 했으니 메서드와 변수까지 사용이 가능해지는 것이다.<br><br>
이어서 implements인데, 자바는 "다중상속"을 지원하지 않는다.<br>
다중상속이란 부모클래스가 두 개 이상 존재할 수 있다는 것인데, 자바에서는 이를 지원하지 않는다.<br>즉 public class MotorCycle extends Price, Brand{...} 이것처럼 불가능 하다는 것이다. 그래서 등장한 것이 <ins>implements(interface)</ins>이다.


## implements
> implements의 가장 큰 특징은 부모의 메서드를 반드시 오버라이딩(Overriding/재정의)해야 한다는 것이다. 또한 public class MotorCycle extends Price, Brand{...} 같은 다중상속을 대신 가능하게 해준다.

~~~java
interface TestInterface{
  public static int num = 8;
  public void fun1();
  public void fun2();
}

class InterfaceExam implements TestInterface{
  @Override
  public void fun1(){
    System.out.println(num);
  }
  
  @Override
  public void fun2() {
    
  }
}

public class InterfaceSample{
  public static void main(String args[]){
    InterfaceExam exam = new InterfaceExam();
    exam.fun1();
  }
}
~~~

* 정리
1. extends는 일반 클래스와 abstract 클래스 상속에 사용되고, implements는 interface 상속에 사용된다.
2. class가 class를, interface가 interface를 상속 받을 땐 extends를 사용한다.
3. class가 interface를 사용할 땐 implements를 써야하고, interface가 class를 사용할 땐 implements를 쓸 수 없다.
4. extends는 클래스 한 개만 상속 받을 수 있다.
5. extends 자식 클래스는 부모 클래스의 기능을 사용한다.
6. implements는 다중상속이 가능하다.
7. implements는 설계 목적으로 구현 가능하다.
8. implements를 사용하는 클래스는 implements(interface)의 내용을 모두 사용해야 한다(Overriding).
9. extends는 클래스를 확장하는 것이고, implements는 interface를 구현하는 것이다.
10. interface와 보통 class의 차이는 인터페이스는 정의한 메소드를 구현하지 않아도 된다.
11. interface를 상속받는 클래스에서 인터페이스에 정의된 메소드를 구현하면 된다.


# <ins>static class의 특징 정리하기</ins>
> 1. 최상위 class는 static class가 될 수 없다.<br>
	=> (틀린말이다. static 키워드를 단지 안붙일 뿐이다). 최상위 class는 이미 static 클래스라서 static을 붙이면 에러가 나는 것이다. 즉, static을 붙일 필요가 없는 것이지 static 클래스가 아니거나 불가능해서 static을 안 붙이는 것이 아니다.<br>
  2. JAVA에서는 nonstatic class로 extends 할 수 없는 특징이 있다.<br>
    => nonstatic class는 static class의 부모 클래스가 될 수 없다.
  3. NonStatic class는 instance Class를 상속받을 수 없다.<br>

~~~java
public class A{
    class B{ }

    static class C extends B { }
		=>불가능 (B는 nonstatic class이므로 final이 안 붙었지만 불가능)
    static class D extends A { }
		=>가능 (A는 부모 클래스이므로 static 키워드를 안붙였을 뿐)
}
~~~