---
layout: post
title: "about_CS(ComputerScience)"
description: "CS에 대하여"
categories: [CS]
tags: [cs, ComputerScience]
redirect_from:
  - /2022/07/22/
---

> CS에 대하여.

* Kramdown table of contents
{:toc .toc}

# <ins>Unit Of Data</ins>
>컴퓨터가 데이터를 처리하는데 최소 기본 단위는 ‘비트(bit)’이다.<br>
컴퓨터는 모든 입력신호를 1과 0, 즉 이진수로 변환하여 처리한다.<br>
‘비트(bit)’라는 단어 또한 이진수(Binary Digit)의 약자인 ‘bit’라고 불린다.<br>
또한 컴퓨터가 처리하는 정보의 기본 단위는 ‘바이트(Byte)’이다.<br>
1과 0만 가지고 있는 비트가 8개가 모여 바이트(Byte)가 된다.<br>
1바이트는 1캐릭터라고도 불리우며 영어, 숫자, 특수문자를 1개 저장하는데 8비트, 즉 1바이트(1캐릭터)가 소유된다.<br>
(단위에서 비트는 소문자 b, 바이트는 대문자 B로 표기)<br><br>
1비트(bit) = 1 bit<br>
1바이트(Byte) = 8 bit<br>
1킬로바이트(KB) = 1,024 Byte<br>
1메가바이트(MB) = 1,024KB(1,048,576 Byte)<br>
1기가바이트(GB) = 1,024MB(1,073,741,824 Byte)<br>
1테라바이트(TB) = 1,024GB(1,099,511,627,776 Byte)<br>
1페타바이트(PB) = 1,024TB(1,125,899,906,842,624 Byte)<br>
1엑사바이트(EB) = 1,024PB(1,152,921,504,606,846,976 Byte)<br>
1제타바이트(PB) = 1,024EB(1,180,591,620,717,411,303,424 Byte)<br>


# <ins>스레드(thread)</ins>
> 스레드(thread)란?<br>
* 프로세스가 할당받은 자원을 이용하는 실행의 단위.
* 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 Heap, Data, Code 영역을 공유 (멀티 스레드의 경우, 이 프로세스의 영역들을 공유한다)
* 하나의 프로세스를 안에서 다양한 작업을 담당하는 최소 실행 단위를 스레드라고 한다.
* 멀티 스레딩의 경우, 스레드 간의 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시킨다.
* 각각의 스레드는 독립적인 작업을 수행해야 하기 때문에 고유한 스레드 ID, 프로그램 카운터, 레지스터 집합, 스택을 가지고 있다.<br><br>
=> 상식적으로 생각해보면, 하나 보다는 여러 스레드로 작업하는 게 더 좋을 것이라 생각이 들지만, 현실은 그렇게 간단하지 않다. 모든 기술들에는 각각의 기회비용이 존재하고, 싱글 스레드와 멀티 스레드 역시 각각의 장점에 맞는 기회비용들이 존재한다

<a class="post-image" href="{{site.baseurl}}/assets/images/cs/singleVSmulti.png">
<img itemprop="image" data-src="{{site.baseurl}}/assets/images/cs/singleVSmulti.png" src="{{site.baseurl}}/assets/javascripts/unveil/loader.gif" alt="왜안떠" />
</a>

## 싱글스레드(single thread)
> 하나의 프로세스에서 오직 하나의 스레드로만 실행한다. 그렇기 때문에, 하나의 레지스터와 스택으로 표현이 가능하다.

<a class="post-image" href="{{site.baseurl}}/assets/images/cs/single.gif">
<img itemprop="image" data-src="{{site.baseurl}}/assets/images/cs/single.gif" src="{{site.baseurl}}/assets/javascripts/unveil/loader.gif" alt="왜안떠" />
</a>

> <b>👏싱글 스레드의 장점</b>
1. <ins>문맥 교환(context switch) 작업을 요구하지 않는다.</ins><br>
=> 문맥 교환은 여러 개의 프로세스가 하나의 프로세서를 공유할 때 발생하는 작업으로 많은 비용을 필요로 한다.
2. <ins>자원 접근에 대한 동기화를 신경쓰지 않아도 된다.</ins><br>
=> 여러 개의 스레드가 프로세스의 자원을 공유할 경우, 각 스레드가 원하는 결과를 얻게 하려면 공용 자원에 대한 접근을 제어해야 한다. 쉽게 말해서, 모든 스레드가 일정 자원에 동시에 접근하거나, 똑같은 작업을 실행하려는 경우, 에러가 발생하거나 원하는 값이 나오지 않는다. 그래서, 스레드들이 동시에 같은 자원에 접근하지 못하도록 제어해줘야만 한다. 이 작업은 프로그래머에게 많은 노력을 요구하고 비용을 발생시킨다.
3. <ins>단순히 CPU만을 사용하는 계산작업이라면, 오히려 멀티스레드보다 싱글스레드로 프로그래밍하는 것이 더 효율적이다.</ins><br>
=> 두 개의 작업을 하나의 스레드로 처리하는 경우 VS  두 개의 스레드로 처리하는 경우<br>
후자의 경우는 짧은 시간 동안 2개의 스레드가 번갈아가면서 작업을 수행한다. 그래서 동시에 두 작업이 처리되는 것과 같이 느끼게 된다.
하지만, 오히여 두 개의 스레드로 작업한 시간이 싱글스레드로 작업한 시간보다 더 걸릴 수도 있는데, 그 이유는 스레드 간의 작업전환(context switching)에 시간이 걸리기 때문이다.
다시 말해서, 단순히 CPU만을 사용하는 작업은 싱글 스레드가 멀티 스레드보다 빠르다.
4. <ins>프로그래밍 난이도가 쉽고, CPU, 메모리를 적게 사용한다.(코스트가 적게든다)</ins><br>
반면에, 멀티 스레드 모델은 프로그래밍 난이도가 높다. 또한, 스레드 수만큼 자원을 많이 사용한다.

> <b>⚠️싱글 스레드의 단점</b>
1. <ins>여러 개의 CPU를 활용하지 못한다.</ins><br>
=> 프로세서를 최대한 활용하게 하려면 cluster 모듈을 사용하거나 외부에서 여러 개의 프로그램 인스턴스를 실행시키는 방법을 사용해야 한다. 이 때 고려해야할 문제가 있는데, 바로 다수의 프로그램 인스턴스가 어떻게 상태를 공유할 것인가에 대한 문제다.
(사실 이것은 멀티 스레드 환경의 서버 프로그램도 확장성을 확보하기 위해 풀어야 할 숙제이긴 하다.)
단순하고 빠른 메모리 기반 NoSQL 데이터 베이스인 Redist가 좋은 고려대상이다.
하지만 서버 프로그램 인스턴스 간 상태 공유를 최소화하거나 가능하면 없애는 방향으로 아키텍처를 설계하는 것이 가장 바람직한 방법이라고 한다.
2. <ins>연산량이 많은 작업을 하는 경우, 그 작업이 완료되어야 다른 작업을 수행할 수 있다.</ins><br>
=> 예를 들어, 웹 게임에서 좌표를 계산하는데 3초가 걸리고 계산된 좌표를 받아 DOM에 반영한다고 생각해봅시다. 좌표를 계산하느라 3초간 DOM 업데이트 등의 다른 작업들을 수행할 수가 없습니다. 사용자 입장에서는 3초간 멍하니 기다릴 뿐입니다. 좌표를 동시에 여러 번 계산해야 하는 경우 더 심각해집니다. 좌표를 20번 계산하면 3 * 20 = 60초를 기다려야 하는 셈입니다.
3초의 시간은 어쩔 수 없다 치더라도, 계산하는 동안 UI 클릭같은 다른 작업은 진행할 수 있어야 원활한 서비스를 제공할 수 있습니다. 이럴 때는 멀티 스레드가 필요해지는 순간입니다.
3. <ins>싱글 스레드 모델은 에러 처리를 못하는 경우 멈춘다.</ins><br>
=> 멀티 스레드 모델은 에러 발생 시 새로운 스레드를 생성하여 극복한다. 다만, 새로운 스레드 생성이나 놀고 있는 스레드 처리에 비용이 발생한다.

## 멀티스레드(multi thread)
> 멀티 스레드는 CPU의 최대 활용을 위해 프로그램의 둘 이상을 동시에 실행하는 기술이다.<br>
이러한 작업은 컨텍스트 스위칭(Context Switching)을 통해서 이뤄진다. 위의 이미지에서 하나의 스레드에서 다음 스레드로 이동을 하면서, 컨텍스트 스위칭이 일어난다. 그리고, 스위칭이 일어나면서 부분적으로 조금씩 조금씩 각각의 스레드에 대한 작업을 끝내게 된다.<br><br>
=> 다시 말해서, context switching이 엄청 빠르게 일어나면서, 유저(=User)의 시선에서는 프로그램들이 동시에 수행되는 것처럼 보인다.

<a class="post-image" href="{{site.baseurl}}/assets/images/cs/multi.gif">
<img itemprop="image" data-src="{{site.baseurl}}/assets/images/cs/multi.gif" src="{{site.baseurl}}/assets/javascripts/unveil/loader.gif" alt="왜안떠" />
</a>

> <b>👏멀티 스레드의 장점</b>
1. <ins>응답성</ins><br>
=> 프로그램의 일부분(스레드 중 하나)이 중단되거나 긴 작업을 수행하더라도 프로그램의 수행이 계속 되어 사용자에 대한 응답성이 증가한다. 다시 말해서, 멀티 스레드 모델은 에러 발생 시 새로운 스레드를 생성하여 극복한다. 다만, 새로운 스레드 생성이나 놀고 있는 스레드 처리에 비용이 발생한다.(싱글 스레드는 프로그램 일부분이 중단되거나, 에러가 발생하면 프로그램이 멈춘다)<br>
ex) 멀티 스레드가 적용된 웹 브라우저 프로그램에서 하나의 스레드가 이미지 파일을 로드하고 있는 동안, 다른 스레드에서 사용자와 상호작용 가능.
2. <ins>경제성</ins><br>
=> 프로세스 내 자원들과 메모리를 공유하기 때문에 메모리 공간과 시스템 자원 소모가 줄어든다. 스레드 간 통신이 필요한 경우에도 쉽게 데이터를 주고 받을 수 있으며, 프로세스의 context switching과 달리 스레드 간의 context switching은 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다.
3. <ins>멀티프로세서의 활용</ins><br>
=> 다중 CPU 구조에서는 각각의 스레드가 다른 프로세서에서 병렬로 수행될 수 있으므로 병렬성이 증가한다.

> <b>⚠️멀티 스레드의 단점</b>
1. context switching, 동기화 등의 이유 때문에 싱글 코어 멀티 스레딩은 스레드 생성 시간이 오히려 오버헤드로 작용해 단일 스레드보다 느리다.
2. 공유하는 자원에 동시에 접근하는 경우, 프로세스와는 달리 스레드는 데이터와 힙 영역을 공유하기 때문에 어떤 스레드가 다른 스레드에서 사용 중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다. 따라서 동기화가 필요!
3. 멀티 스레딩을 위해서는 운영체제의 지원이 필요하다.
4. 멀티 스레드 모델은 프로그래밍 난이도가 높다. 또한, 스레드 수만큼 자원을 많이 사용한다. 초보자의 경우, 동일한 프로그램을 만든다면, 싱글 스레드로는 완성이라도 한다. 그러나, 멀티 스레드의 경우는 완성도 못하는 경우도 많다.


# <ins>Framework VS Library</ins>
<a class="post-image" href="{{site.baseurl}}/assets/images/cs/framelib.png">
<img itemprop="image" data-src="{{site.baseurl}}/assets/images/cs/framelib.png" src="{{site.baseurl}}/assets/javascripts/unveil/loader.gif" alt="왜안떠" />
</a>

#### Framework(프레임워크)
> 프레임워크는 뼈대나 기반구조를 뜻하고, 제어의 역전 개념이 적용된 대표적인 기술입니다.<br>
소프트웨어에서의 프레임워크는 '소프트웨어의 특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합' 이라 할 수 있으며, 완성된 어플리케이션이 아닌 프로그래머가 완성시키는 작업을 해야합니다.<br>
객체 지향 개발을 하게 되면서 통합성, 일관성의 부족이 발생되는 문제를 해결할 방법중 하나라고 할 수 있습니다.

##### 프레임워크의 특징
> - 특정 개념들의 추상화를 제공하는 여러 클래스나 컴포넌트로 구성되어 있습니다. 
- 추상적인 개념들이 문제를 해결하기 위해 같이 작업하는 방법을 정의합니다. 
- 컴포넌트들은 재사용이 가능합니다. 
- 높은 수준에서 패턴들을 조작화 할 수 있습니다.

#### Library(라이브러리)
> 라이브러리는 단순 활용가능한 도구들의 집합을 말합니다.<br>
즉, 개발자가 만든 클래스에서 호출하여 사용, 클래스들의 나열로 필요한 클래스를 불러서 사용하는 방식을 취하고 있습니다.

## 프레임워크와 라이브러리의 차이점
> 라이브러리와 프레임워크의 차이는 제어 흐름에 대한 주도성이 누구에게 / 어디에 있는가에 있습니다.<br>
즉, 어플리케이션의 Flow(흐름)를 누가 쥐고 있느냐에 달려 있습니다.<br>
<b>프레임워크</b>는 전체적인 흐름을 스스로가 쥐고 있으며 사용자는 그 안에서 필요한 코드를 짜 넣으며 반면, <b>라이브러리</b>는 사용자가 전체적인 흐름을 만들며 라이브러리를 가져다 쓰는 것이라고 할 수 있습니다.<br>
다시 말해, 라이브러리는 라이브러리를 가져다가 사용하고 호출하는 측에 전적으로 주도성이 있으며 프레임워크는 그 틀안에 이미 제어 흐름에 대한 주도성이 내재(내포)하고 있습니다.<br>
프레임워크는 가져다가 사용한다기보다는 거기에 들어가서 사용한다는 느낌/관점으로 접근할 수 있습니다.

> 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어합니다.<br>
단지 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐입니다. <br>
반면에 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용되는 것입니다. <br>
보통 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식입니다.<br>
프레임워크에는 분명한 제어의 역전 개념이 적용되어 있어야 합니다.<br>
애플리케이션 코드는 프레임워크가 짜놓은 틀에서 수동적으로 동작해야 합니다.

> <b>INFO</b><br>
<b>제어의 역전</b>이란 어떠한 일을 하도록 만들어진 프레임워크에 제어의 권한을 넘김으로써 클라이언트 코드가 신경 써야 할 것을 줄이는 전략입니다.<br>
이것을 제어가 역전 되었다 라고 합니다. 일반적으로 라이브러리는 프로그래머가 작성하는 클라이언트 코드가 라이브러리의 메소드를 호출해서 사용하는 것을 의미 합니다. <br>
프레임워크를 규정하는 특성은 프레임워크의 메소드가 사용자의 코드를 호출 한다는데 있습니다. <br>
여기까지는 이해가 쉽지만, 의문이 생깁니다. <br>
대체 어떻게 프레임워크가 나의 메소드를 호출하는가에 대한 의문입니다. <br>
어떻게 하면 프레임워크가 나의 코드를 호출 할 수 있을까? 프레임워크는 내가 작성한 코드를 모르잖아!. <br>
제어를 역전시키는 (프레임워크가 나의 코드를 호출 할 수 있게 하는) 가장 쉽게 생각할 수 있는 접근 방법은 프레임워크의 event, delegate 에 나의 메소드를 등록 시키는 것입니다. <br>
전달되는 인자와 반환 형식만 일치 한다면, 프레임워크 코드는 내가 작성한 객체와 타입을 고려하지 않습니다. <br>
등록된 메소드만 감지하여 실행 invoke 하는 것입니다. <br>
다른 방법은 프레임워크에 정의 되어 있는 인터페이스 interface, 추상타입 abstract 을 나의 코드에서 구현, 상속 한후 프레임워크에 넘겨주는 것입니다. <br>
프레임워크는 인터페이스와 추상을 알고 있으므로 내가 하고자 하는 일련의 작업을 처리할 수 있습니다. <br>
이는 객체를 프레임워크에 주입하는 것이고, 이를 의존을 주입 dependency injection 한다고 합니다.

#### 이해하기 쉬운 예
> <b>라이브러리</b>는 톱, 망치, 삽같은 연장입니다. <br>
사람이 들고 썰고, 바꿔들고 내려치고, 다시 바꿔들고 땅을 파는 겁니다. <br>
<b>프레임워크</b>는 차, 비행기, 배같은 탈 것입니다. <br>
사람이 타서 엔진 켜고, 기어 넣고, 핸들 돌리고, 운전하거나, 조종하거나 해야합니다. <br>
<u>도구를 쓸 때, 급하면 썰어야 할 곳에 망치를 쳐도 됩니다. 땅 파야할 때 톱으로 땅을 긁어내도 됩니다</u>.<br> 
사람은 도구를 선택하는 입장이기 때문에, 어떤 도구를 사용하든 원하는 것을 만들어낼 수 만 있으면 됩니다. <br>
<u>반면에, 탈것은 정해진 곳으로만 다녀야 합니다</u>. <br>
차를 타고 하늘을 날거나, 배를 타고 땅으로 갈 수는 없습니다. <br>
하지만, 그 목적에 맞게 만들어져 있기 때문에, 톱이나 망치를 들고 먼저 탈것을 만들어야 할 필요가 없습니다. <br>
그저 정해진 규칙에 맞춰서 엔진, 기어, 핸들만 잘 돌리면 되는 것입니다. 

출처: https://webclub.tistory.com/458 [Web Club]


# <ins>API(Application Programming Interface)</ins>
<a class="post-image" href="{{site.baseurl}}/assets/images/cs/api1.png">
<img itemprop="image" data-src="{{site.baseurl}}/assets/images/cs/api1.png" src="{{site.baseurl}}/assets/javascripts/unveil/loader.gif" alt="왜안떠" />
</a>

#### API의 역할? 
> 1. API는 서버와 데이터베이스에 대한 출입구 역할을 한다.
데이터베이스에는 소중한 정보들이 저장 되는데, 누구나 접근할 수 있으면 안 되기에 API는 이를 방지하기 위해 서버와 데이터베이스에 대한 출입구 역할을 하며, 허용된 사람들에게만 접근성을 부여해준다.
2. API는 애플리케이션과 기기가 원활하게 통신할 수 있도록 한다.
여기서 애플리케이션이란 우리가 흔히 알고 있는 스마트폰 어플이나 프로그램을 말한다. API는 애플리케이션과 기기가 데이터를 원활히 주고받을 수 있도록 돕는 역할을 한다.
3. API는 모든 접속을 표준화한다.
API는 모든 접속을 표준화하기 때문에 기계 / 운영체제 등과 상관없이 누구나 동일한 액세스를 얻을 수 있다. 쉽게 말해, API는 범용 플러그처럼 작동한다고 볼 수 있다.

#### API유형은?
> 1. private API
private API는 내부 API로, 회사 개발자가 자체 제품과 서비스를 개선하기 위해 내부적으로 발행한다. 따라서 제 3자에게 노출되지 않는다.
2. public API
public API는 개방형 API로, 모두에게 공개되고 누구나 제한 없이 API를 사용할 수 있는 게 특징이다.
3. partner API
partner API는 기업이 데이터 공유에 동의하는 특정인들만 사용할 수 있다. 비즈니스 관계에서 사용되는 편이며, 종종 파트너 회사 간에 소프트웨어를 통합하기 위해 사용된다.

#### API 사용하면 좋은점?
> Private API를 이용 할 경우, 개발자들이 애플리케이션 코드를 작성하는 방법을 표준화함으로써, 간소화되고 빠른 프로세스 처리를 가능하게 한다. 또한, 소프트웨어를 통합하고자 할 때는 개발자들 간의 협업을 용이하게 만들어줄 수 있다.  
public API와 partner API 를 사용하면, 기업은 타사 데이터를 활용하여 브랜드 인지도를 높일 수 있고, 고객 데이터베이스를 확장하여 전환율까지 높일 수 있다.


# <ins>WEB과 WAS의 차이점</ins>
## WEB? WAS란?
#### 웹서버(WEB)란?
> <b>웹 서버는 말 그대로 작성된 html페이지 등을 네트워크망에 종속되지 않고, 웹서비스를 할 수 있도록 하는 애플리케이션</b>
- 웹 서버(소프트웨어) : 웹 브라우저 클라이언트로부터 HTTP요청을 받아들이고, HTML문서와 같은 웹 페이지에서 흔희 찾아볼 수 있는 자료 콘텐츠에 따라 HTTP에 반응하는 컴퓨터 프로그램
- 웹 서버(하드웨어) : 위 소프트웨어의 기능을 제공하는 컴퓨터 프로그램을 실행하는 컴퓨터

#### 웹 애플리케이션 서버(WAS, Web Application Server)란?
> <b>웹 서버 + 웹 컨테이너</b>  
인터넷 상에서 HTTP를 통해 사용자 컴퓨터나 장치에 애플리케이션을 수행해 주는 미들웨어(소프트웨어 엔진)이다. 웹 애플리케이션 서버는 동적 서버 콘텐츠를 수행하는 것으로 일반적인 웹 서버와 구별이 되며, 주로 데이터베이스 서버와 같이 수행이 된다.  
웹 서버 + 웹 컨테이너로 웹 상에서 사용하는 컴포넌트를 올려놓고 사용하게 되는 서버이다. 여기서 웹 컨테이너란, JSP와 Servlet을 실행시킬 수 있는 SW를 웹 컨테이너라고 한다.
- 기본 기능
1. 프로그램 실행 환경과 데이터베이스 접속 기능을 제공한다.
2. 여러 개의 트랜잭션을 관리한다.
3. 업무를 처리하는 비즈니스 로직을 수행한다.
4. Web Service 플랫폼으로서의 역할.
<a class="post-image" href="{{site.baseurl}}/assets/images/cs/was01.png">
<img itemprop="image" data-src="{{site.baseurl}}/assets/images/cs/was01.png" src="{{site.baseurl}}/assets/javascripts/unveil/loader.gif" alt="왜안떠" />
</a>

#### 웹 컨테이너(Web Container)
> JSP와 서블릿을 실행시킬 수 있는 소프트웨어를 웹 컨테이너 혹은 서블릿 컨테이너라고 한다.  
웹 서버에서 JSP를 요청하면 톰캣에서는 JSP파일을 서블릿으로 변환하여 컴파일을 수행하고, 서블릿 수행결과를 웹서버에게 전달하게 된다.  
JSP 컨테이너가 탑재 되어 있는 WAS는 JSP 페이지를 컴파일 해, 동적인 페이지를 생성한다.  
Servlet 컨테이너, JSP 컨테이너, EJB 컨테이너 등의 종류가 있다.(WebLogic 등)

## 대표적인 WEB과 WAS의 종류
#### apache
> apache란 소프트웨어 단체 이름이다.  
그리고 우리가 흔히 부르는 아파치서버라는 것은 이 재단에서 후원하는 오픈소스 프로젝트 커뮤니티에서 만든 http웹서버를 말한다.  
클라이언트가 GET, POST, DELETE 등의 메소드를 이용해 요청을 하면 이 프로그램이 어떤 결과를 돌려주는 기능을 한다.  
http 웹서버는 http 요청을 처리할 수 있는 웹서버이고, 아파치 http 서버는 http 요청을 처리하는 즉, 웹서버인 것이다.  

#### tomcat
> tomcat은 흔히 WAS라고 말한다.  
WAS는 웹서버와 웹 컨테이너의 결합으로 다양한 기능을 컨테이너에 구현하고, 다양한 역할을 수행할 수 있는 서버를 말한다.  
클라이언트의 요청이 있을 때, 내부의 프로그램을 통해 결과를 만들어내고 이것을 다시 클라이언트에 전달해주는 역할을 하는 것이 바로 웹 컨테이너이다.  
위의 아파치 웹 서버와 차이는 이 컨테이너 기능이 가능하냐의 차이가 가장 크다고 생각한다.  
<a class="post-image" href="{{site.baseurl}}/assets/images/cs/diff01.png">
<img itemprop="image" data-src="{{site.baseurl}}/assets/images/cs/diff01.png" src="{{site.baseurl}}/assets/javascripts/unveil/loader.gif" alt="왜안떠" />
</a>

## WEB과 WAS의 비교와 차이점
#### 비교
> Web Container의 유무로 WEB과 WAS를 나눌 수 있으며, <b>WEB</b>서버는 HTML 문서같은 정적 컨텐츠를 처리하는 것이고 <b>WAS</b>서버는 asp, php, jsp 등 개발 언어를 읽고 처리하여 동적 컨텐츠, 웹 응용 프로그램 서비스를 처리하는 것이다. 

#### 차이점
> 웹 서버는 정적인 데이터를 처리하는 서버이다. 이미지나 단순 HTML 파일과 같은 리소스를 제공하는 서버를 웹 서버를 통하면 WAS를 이용하는 것보다 빠르고 안정적이다.  
WAS는 동적인 데이터를 처리하는 서버이다. DB와 연결되어 데이터를 주고 받거나 프로그램으로 데이터 조작이 필요한 경우에는 WAS를 활용해야 한다.  
우리가 만드는 웹페이지는 정적 컨텐츠와 동적 컨텐츠를 함께 노출한다. WAS가 정적 데이터를 처리하게 되면, 동적 컨텐츠의 처리가 지연이 될 것이고, 이로 인해 페이지 노출시간이 늘어나게 된다.  
WAS는 동적 처리에 최적화 되어 있는 서비스이기 때문에 처리 속도를 위해 정적처리는 웹서버에서 처리를 하고, 동적 컨텐츠는 WAS에서 처리하게 된다. 